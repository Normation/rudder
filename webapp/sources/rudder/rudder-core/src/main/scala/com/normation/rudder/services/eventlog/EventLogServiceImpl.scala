/*
 *************************************************************************************
 * Copyright 2011 Normation SAS
 *************************************************************************************
 *
 * This file is part of Rudder.
 *
 * Rudder is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * In accordance with the terms of section 7 (7. Additional Terms.) of
 * the GNU General Public License version 3, the copyright holders add
 * the following Additional permissions:
 * Notwithstanding to the terms of section 5 (5. Conveying Modified Source
 * Versions) and 6 (6. Conveying Non-Source Forms.) of the GNU General
 * Public License version 3, when you create a Related Module, this
 * Related Module is not considered as a part of the work and may be
 * distributed under the license agreement of your choice.
 * A "Related Module" means a set of sources files including their
 * documentation that, without modification of the Source Code, enables
 * supplementary functions or services in addition to those offered by
 * the Software.
 *
 * Rudder is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Rudder.  If not, see <http://www.gnu.org/licenses/>.

 *
 *************************************************************************************
 */

package com.normation.rudder.services.eventlog

import cats.data.*
import com.normation.box.*
import com.normation.errors
import com.normation.errors.Chained
import com.normation.errors.Inconsistency
import com.normation.errors.IOResult
import com.normation.errors.SystemError
import com.normation.eventlog.*
import com.normation.eventlog.EventLogRequest.PrincipalFilter
import com.normation.rudder.batch.CurrentDeploymentStatus
import com.normation.rudder.domain.eventlog.*
import com.normation.rudder.domain.logger.EventLogsLoggerPure
import com.normation.rudder.repository.EventLogRepository
import doobie.*
import doobie.implicits.*
import net.liftweb.common.*
import scala.annotation.nowarn
import zio.syntax.*

class EventLogServiceImpl(val repository: EventLogRepository) extends EventLogService {

  import EventLogServiceImpl.*

  /**
   * Users don't want to see logs generated by the web application i.e. event log with principal='rudder'.
   * @param filter the filter case class
   * @return the list of event logs for users.
   */
  override def getUserEventLogs(filter: Option[EventLogRequest]): IOResult[Seq[EventLog]] = {
    (for {
      events <-
        repository
          .getEventLogByCriteria(excludeRudderEventLogs(filter))
          .chainError(
            s"Error when trying fetch event logs from database for page ${filter.map(_.start).getOrElse(0) / filter.map(_.length).getOrElse(0) + 1}"
          )
    } yield {
      events
    }).catchSystemErrors
  }

  override def getEventLogCount(filter: Option[EventLogRequest]): IOResult[Long] = {
    (for {
      events <- repository
                  .getEventLogCount(excludeRudderEventLogs(filter))
                  .chainError(s"Error when counting event logs from database")
    } yield {
      events
    }).catchSystemErrors
  }

  private def excludeRudderEventLogs(filter: Option[EventLogRequest]) = {
    val rudderActors      = NonEmptyList.of(RudderEventActor, RudderSystemEventActor)
    val excludePrincipals = filter
      .flatMap(f => f.principal)
      .flatMap(_.exclude)
      .map(_.concatNel(rudderActors))
      .getOrElse(rudderActors)
    val includePrincipals = filter.flatMap(f => f.principal).flatMap(_.include)
    filter.map(f => {
      f.copy(principal = Some(PrincipalFilter(includePrincipals, Some(excludePrincipals))))
    })
  }
}

object EventLogServiceImpl {
  extension [A](io: IOResult[A]) {
    def catchSystemErrors: IOResult[A] = io.catchSome {
      case err: SystemError =>
        EventLogsLoggerPure.error(err.fullMsg) *>
        Inconsistency("A database error occurred").fail

      // in case user had called chainError once on a database call
      case Chained(msg, err: SystemError) =>
        EventLogsLoggerPure.error(err.fullMsg) *>
        Inconsistency(msg).fail
    }
  }

}

class EventLogDeploymentService(
    val repository:             EventLogRepository,
    val eventLogDetailsService: EventLogDetailsService
) {

  /**
   * Fetch the last deployment (may it be failure or success)
   */
  def getLastDeployement(): Box[CurrentDeploymentStatus] = {
    val query = fr"eventtype in (${SuccessfulDeploymentEventType.serialize}, ${FailedDeploymentEventType.serialize})"
    (repository
      .getEventLogByCriteria(Some(query), Some(1), List(Fragment.const("creationdate desc")), None)
      .toBox: @unchecked @nowarn("msg=deprecated")) match {
      case Full(seq) if seq.size > 1  => Failure("Too many answer from last policy update")
      case Full(seq) if seq.size == 1 =>
        eventLogDetailsService.getDeploymentStatusDetails(seq.head.details)
      case Full(seq) if seq.isEmpty   => Empty
      case f: EmptyBox => f
    }
  }

  /**
   * Fetch the last successful deployment (which may be empty)
   */
  def getLastSuccessfulDeployement(): Box[EventLog] = {
    val query = fr"eventtype = ${SuccessfulDeploymentEventType.serialize}"
    (repository
      .getEventLogByCriteria(Some(query), Some(1), List(Fragment.const("creationdate desc")), None)
      .toBox: @unchecked @nowarn("msg=deprecated")) match {
      case Full(seq) if seq.size > 1  => Failure("Too many answer from last policy update")
      case Full(seq) if seq.size == 1 => Full(seq.head)
      case Full(seq) if seq.isEmpty   => Empty
      case f: EmptyBox => f
    }
  }

  /**
   * Return the list of event corresponding at a modification since last successful deployment
   *
   */
  def getListOfModificationEvents(lastSuccess: EventLog): errors.IOResult[Seq[EventLog]] = {
    ModificationWatchList.events.toList.map(_.serialize) match {
      case Nil    => Nil.succeed
      case h :: t =>
        val query =
          Fragments.and(Fragments.in(fr"eventtype", NonEmptyList.of(h, t*)), fr" id > ${lastSuccess.id.getOrElse(0)}")
        repository.getEventLogByCriteria(Some(query), None, List(Fragment.const("id DESC")), None): @nowarn("msg=deprecated")
    }
  }

}

#####################################################################################
# Copyright 2016 Normation SAS
#####################################################################################
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, Version 3.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#####################################################################################

# Used in Rudder tests
body package_module test
{
      query_installed_ifelapsed => "$(ncf_def.package_module_query_installed_ifelapsed)";
      query_updates_ifelapsed => "$(ncf_def.package_module_query_updates_ifelapsed)";
      #default_options =>  {};
}

# Not upstream
body package_module zypper_pattern
{
      query_installed_ifelapsed => "$(ncf_def.package_module_query_installed_ifelapsed)";
      query_updates_ifelapsed => "$(ncf_def.package_module_query_updates_ifelapsed)";
      #default_options =>  {};
}

# Not upstream
body package_module ips
{
      query_installed_ifelapsed => "$(ncf_def.package_module_query_installed_ifelapsed)";
      query_updates_ifelapsed => "$(ncf_def.package_module_query_updates_ifelapsed)";
      #default_options =>  {};
}

# Called by package_* generic methods
bundle agent ncf_package(name, version, architecture, provider, state, options)
{
  vars:
      "class_prefix"       string => "ncf_package_${state}_${name}";

    # Build string vars used for reporting

    # State
    state_present::
      "state_description" string => "Presence";
    !state_present::
      "state_description" string => "Absence";

    # Architecture
    architecture_specified::
      "architecture_description" string => " for ${architecture} architecture ";
    !architecture_specified::
      "architecture_description" string => " ";

    # Version
    version_latest::
      "version_description" string => "in latest available version";
    !version_specified::
      "version_description" string => "in any version";
    version_specified.!version_latest::
      "version_description" string => "in version ${version}";
    
    # Log message
    pass3.!(!state_present.version_latest)::
      "message" string => "If you tried to install a virtual package, please use in place the concrete package you want to install.${const.endl}${state_description} of package ${name}${architecture_description}${version_description}",
            ifvarclass => "${report_data.method_id}_not_ok";

      "message" string => "${state_description} of package ${name}${architecture_description}${version_description}",
            ifvarclass => "!${report_data.method_id}_not_ok";
      "message" string => "Package methods using apt, yum, zypper and zypper_pattern require Python (2 or 3) present on the system to work.${const.endl}${state_description} of package ${name}${architecture_description}${version_description}",
                    if => "!_have_python.(use_apt_provider|use_yum_provider|use_zypper_provider|use_zypper_pattern_provider)";

    !state_present.version_latest::
      "message" string => "${state_description} of package ${name}${architecture_description}${version_description} is not supported and";

  defaults:
      "version"      string => "any", if_match_regex => "";
      "architecture" string => "default", if_match_regex => "";
      "provider"     string => "default", if_match_regex => "";
      # Select the default packager for this platform if "default"
      "provider"     string => "${package_module_knowledge.platform_default}", if_match_regex => "default";
      "state"        string => "present", if_match_regex => "";

  classes:
      "version_latest"  expression => strcmp("latest", "${version}");
      # As "latest" is understood by package promises,
      # the only special case is "any", which maps to
      # no specified version in the promise
      "version_specified"      not => strcmp("any", "${version}");

      "state_present" expression => strcmp("present", "${state}");

      # If architecture is not specified, do not add it to the promise.
      # The package module will pick the default one for the local platform
      "architecture_specified" not => strcmp("default", "${architecture}");

      # Select the right package manager
      # The default one has already been selected if needed using mackage_module_knowledge
      # use both apt to be compatible with generic method and apt_get for compatibility with knowledge
      "use_apt_provider" expression => strcmp("apt_get", "${provider}");
      "use_apt_provider" expression => strcmp("apt", "${provider}");
      "use_yum_provider" expression => strcmp("yum", "${provider}");
      "use_zypper_provider" expression => strcmp("zypper", "${provider}");
      "use_zypper_pattern_provider" expression => strcmp("zypper_pattern", "${provider}");
      "use_pkg_provider" expression => strcmp("pkg", "${provider}");
      "use_slackpkg_provider" expression => strcmp("slackpkg", "${provider}");
      "use_ips_provider" expression => strcmp("ips", "${provider}");
      "use_nimclient_provider" expression => strcmp("nimclient", "${provider}");
      "use_snap_provider" expression => strcmp("snap", "${provider}");
      # Used in tests
      "use_test_provider" expression => strcmp("test", "${provider}");

    any::
      "supported_provider" expression => "use_apt_provider|use_yum_provider|use_zypper_provider|use_pkg_provider|use_slackpkg_provider|use_test_provider|use_zypper_pattern_provider|use_ips_provider|use_nimclient_provider|use_snap_provider";

      "pass3" expression => "pass2";
      "pass2" expression => "pass1";
      "pass1" expression => "any";

  packages:

    # Unfortunately, we have to duplicate the 4 cases for each supported package module
    
    #### apt ####

    use_apt_provider.architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => apt_get,
          architecture   => "${architecture}",
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_apt_provider.architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => apt_get,
          architecture   => "${architecture}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_apt_provider.!architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => apt_get,
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_apt_provider.!architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => apt_get,
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    #### yum ####

    use_yum_provider.architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => yum,
          architecture   => "${architecture}",
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_yum_provider.architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => yum,
          architecture   => "${architecture}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_yum_provider.!architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => yum,
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_yum_provider.!architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => yum,
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    #### zypper ####

    use_zypper_provider.architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => zypper,
          architecture   => "${architecture}",
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_zypper_provider.architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => zypper,
          architecture   => "${architecture}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_zypper_provider.!architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => zypper,
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_zypper_provider.!architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => zypper,
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    #### zypper-pattern ####

    use_zypper_pattern_provider.architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => zypper_pattern,
          architecture   => "${architecture}",
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_zypper_pattern_provider.architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => zypper_pattern,
          architecture   => "${architecture}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_zypper_pattern_provider.!architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => zypper_pattern,
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_zypper_pattern_provider.!architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => zypper_pattern,
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    #### pkg ####

    use_pkg_provider.architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => pkg,
          architecture   => "${architecture}",
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_pkg_provider.architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => pkg,
          architecture   => "${architecture}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_pkg_provider.!architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => pkg,
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_pkg_provider.!architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => pkg,
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    #### slackpkg ####

    use_slackpkg_provider.architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => slackpkg,
          architecture   => "${architecture}",
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_slackpkg_provider.architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => slackpkg,
          architecture   => "${architecture}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_slackpkg_provider.!architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => slackpkg,
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_slackpkg_provider.!architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => slackpkg,
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

     #### ips ####

    use_ips_provider.architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => ips,
          architecture   => "${architecture}",
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_ips_provider.architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => ips,
          architecture   => "${architecture}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_ips_provider.!architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => ips,
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_ips_provider.!architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => ips,
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    #### nimclient ####
 
    use_nimclient_provider.architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => nimclient,
          architecture   => "${architecture}",
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_nimclient_provider.architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => nimclient,
          architecture   => "${architecture}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_nimclient_provider.!architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => nimclient,
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_nimclient_provider.!architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => nimclient,
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");


    #### snap ####

    use_snap_provider.architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => snap,
          architecture   => "${architecture}",
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_snap_provider.architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => snap,
          architecture   => "${architecture}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_snap_provider.!architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => snap,
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_snap_provider.!architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => snap,
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");


    #### test ####

    use_test_provider.architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => test,
          architecture   => "${architecture}",
          version        => "${version}",
          options        => { "test_db" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_test_provider.architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => test,
          architecture   => "${architecture}",
          options        => { "test_db" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_test_provider.!architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => test,
          version        => "${version}",
          options        => { "test_db" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_test_provider.!architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => test,
          options        => { "test_db" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

  methods:
    !supported_provider::
      "force failure class" usebundle => _classes_failure("${class_prefix}");
      "force failure class" usebundle => _classes_failure("${report_data.method_id}");
}

#### Old package promises

# DEPRECATED
bundle common rudder_debian_knowledge
# @depends paths
# @brief common Rudder Debian knowledge bundle
#
# This common bundle has useful information about Debian.
{
  vars:
      "dpkg_compare_equal" string => "/usr/bin/dpkg --compare-versions '${v1}' eq '${v2}'";
      "dpkg_compare_less"  string => "/usr/bin/dpkg --compare-versions '${v1}' lt '${v2}'";
}

# DEPRECATED
bundle common rudder_rpm_knowledge
# @depends paths
# @brief common Rudder RPM knowledge bundle
#
# This common bundle has useful information about platforms using RPM
{
  vars:
      "rpm_compare_equal" string => "${sys.workdir}/bin/rpmvercmp '${v1}' eq '${v2}'";
      "rpm_compare_less"  string => "${sys.workdir}/bin/rpmvercmp '${v1}' lt '${v2}'";

}

# DEPRECATED
body package_method yum_rpm_no_version
{
    package_changes => "bulk";
    package_list_command => "/bin/rpm -qa --qf '%{name}.%{arch} %{version}-%{release}\n'";
    package_patch_list_command => "/usr/bin/yum ${redhat_knowledge.yum_options} check-update";

    package_list_name_regex    => "([^.]+).*";
    package_list_version_regex => "[^\s]\s+([^\s]+).*";
    package_list_arch_regex    => "[^.]+\.([^\s]+).*";

    package_installed_regex => ".*";
    package_name_convention => "$(name)";

    # just give the package name to rpm to delete, otherwise it gets "name.*" (from package_name_convention above)
    package_delete_convention => "$(name)";

    # set it to "0" to avoid caching of list during upgrade
    package_list_update_command => "/usr/bin/yum ${redhat_knowledge.yum_options} check-update";
    package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";

    package_patch_installed_regex => "^\s.*";
    package_patch_name_regex    => "([^.]+).*";
    package_patch_version_regex => "[^\s]\s+([^\s]+).*";
    package_patch_arch_regex    => "[^.]+\.([^\s]+).*";


    package_add_command    => "$(redhat_knowledge.call_yum) $(redhat_knowledge.yum_options) -y install";
    package_update_command => "$(redhat_knowledge.call_yum) $(redhat_knowledge.yum_options) -y update";
    package_patch_command  => "$(redhat_knowledge.call_yum) $(redhat_knowledge.yum_options) -y update";
    package_delete_command => "$(rpm_knowledge.call_rpm) -e --nodeps";
    package_verify_command => "$(rpm_knowledge.call_rpm) -V";
    package_noverify_returncode => "1";
    package_version_less_command => "$(redhat_knowledge.rpm_compare_less)";
    package_version_equal_command => "$(redhat_knowledge.rpm_compare_equal)";
}

# Install packages using yum localinstall, disable package caching
# DEPRECATED
body package_method redhat_local_install
{
  redhat::
    package_changes => "bulk";
    package_list_command => "/bin/rpm -qa --qf '%{name} %{version}-%{release} %{arch}\n'";
    package_patch_list_command => "/usr/bin/yum ${redhat_knowledge.yum_options} check-update";
    package_list_name_regex    => "^(\S+?)\s\S+?\s\S+$";
    package_list_version_regex => "^\S+?\s(\S+?)\s\S+$";
    package_list_arch_regex    => "^\S+?\s\S+?\s(\S+)$";
    package_installed_regex => ".*";
    package_name_convention => "$(name)";
    package_list_update_command => "/usr/bin/yum ${redhat_knowledge.yum_options} check-update";
    package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";
    package_patch_installed_regex => "^\s.*";
    package_patch_name_regex    => "([^.]+).*";
    package_patch_version_regex => "[^\s]\s+([^\s]+).*";
    package_patch_arch_regex    => "[^.]+\.([^\s]+).*";
    package_add_command    => "/usr/bin/yum ${redhat_knowledge.yum_options} -y localinstall";
    package_update_command => "/usr/bin/yum ${redhat_knowledge.yum_options} -y update";
    package_patch_command => "/usr/bin/yum ${redhat_knowledge.yum_options} -y update";
    package_delete_command => "/bin/rpm -e --nodeps --allmatches";
    package_verify_command => "/bin/rpm -V";
    package_noverify_returncode => "1";
    package_version_less_command => "$(redhat_knowledge.rpm_compare_less)";
    package_version_equal_command => "$(redhat_knowledge.rpm_compare_equal)";
}
# Install packages using yum standard install, disable package caching
# DEPRECATED
body package_method redhat_install
{
  redhat::
    package_changes => "bulk";
    package_list_command => "/bin/rpm -qa --qf '%{name} %{version}-%{release} %{arch}\n'";
    package_patch_list_command => "/usr/bin/yum ${redhat_knowledge.yum_options} check-update";
    package_list_name_regex    => "^(\S+?)\s\S+?\s\S+$";
    package_list_version_regex => "^\S+?\s(\S+?)\s\S+$";
    package_list_arch_regex    => "^\S+?\s\S+?\s(\S+)$";
    package_installed_regex => ".*";
    package_name_convention => "$(name)";
    package_list_update_command => "/usr/bin/yum ${redhat_knowledge.yum_options} check-update";
    package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";
    package_patch_installed_regex => "^\s.*";
    package_patch_name_regex    => "([^.]+).*";
    package_patch_version_regex => "[^\s]\s+([^\s]+).*";
    package_patch_arch_regex    => "[^.]+\.([^\s]+).*";
    package_add_command    => "/usr/bin/yum ${redhat_knowledge.yum_options} -y install";
    package_update_command => "/usr/bin/yum ${redhat_knowledge.yum_options} -y update";
    package_patch_command => "/usr/bin/yum ${redhat_knowledge.yum_options} -y update";
    package_delete_command => "/bin/rpm -e --nodeps --allmatches";
    package_verify_command => "/bin/rpm -V";
    package_noverify_returncode => "1";
    package_version_less_command => "$(redhat_knowledge.rpm_compare_less)";
    package_version_equal_command => "$(redhat_knowledge.rpm_compare_equal)";
}

# DEPRECATED
body package_method debian_local_install
{
    package_changes => "individual";
    package_list_command => "$(debian_knowledge.call_dpkg) -l";
    # set it to "0" to avoid caching of list during upgrade
    package_list_update_command => "$(debian_knowledge.call_apt_get) update";
    package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";
    package_list_name_regex    => ".i\s+([^\s]+).*";
    package_list_version_regex => ".i\s+[^\s]+\s+([^\s]+).*";
    package_installed_regex => ".i.*"; # packages that have been uninstalled may be listed
    package_file_repositories => { "$(repo)" };
    package_add_command => "$(debian_knowledge.call_dpkg) --install";
    package_delete_command => "$(debian_knowledge.call_dpkg) --purge";
    package_update_command =>  "$(debian_knowledge.call_dpkg) --install";
    package_patch_command =>  "$(debian_knowledge.call_dpkg) --install";

    # make correct version comparisons
    package_version_less_command => "$(debian_knowledge.dpkg_compare_less)";
    package_version_equal_command => "$(debian_knowledge.dpkg_compare_equal)";

  x86_64::
    package_name_convention => "$(name)_$(version)_amd64.deb";
  i686::
    package_name_convention => "$(name)_$(version)_i386.deb";
  have_aptitude::
    package_patch_list_command => "/usr/bin/aptitude --assume-yes --simulate --verbose full-upgrade";
    package_patch_name_regex => "^Inst\s+(\S+)\s+.*";
    package_patch_version_regex => "^Inst\s+\S+\s+\[?\(?([^\],\s]+).*";
  !have_aptitude::
    package_patch_list_command => "$(debian_knowledge.call_apt_get) --just-print dist-upgrade";
    package_patch_name_regex => "^Inst\s+(\S+)\s+.*";
    package_patch_version_regex => "^Inst\s+\S+\s+\[?\(?([^\],\s]+).*";
}

# DEPRECATED
body package_method ncf_generic
{
  SuSE::
    package_changes => "bulk";
    package_list_command => "/bin/rpm -qa --queryformat \"i | repos | %{name} | %{version}-%{release} | %{arch}\n\"";
    # set it to "0" to avoid caching of list during upgrade
    package_list_update_command => "/usr/bin/zypper --non-interactive refresh";
    package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";
    package_installed_regex => "i.*";
    package_list_name_regex    => "[^|]+\|[^|]+\|\s+([^\s]+).*";
    package_list_version_regex => "[^|]+\|[^|]+\|[^|]+\|\s+([^\s]+).*";
    package_list_arch_regex    => "[^|]+\|[^|]+\|[^|]+\|[^|]+\|\s+([^\s]+).*";
    package_patch_name_regex    => "[^|]+\|\s+([^\s]+).*";
    package_patch_version_regex => "[^|]+\|[^|]+\|\s+([^\s]+).*";
    package_name_convention => "$(name)";
    package_add_command => "/usr/bin/zypper --non-interactive install";
    package_delete_command => "/usr/bin/zypper --non-interactive remove --force-resolution";
    package_update_command => "/usr/bin/zypper --non-interactive update";
    package_patch_command => "/usr/bin/zypper --non-interactive patch$"; # $ means no args
    package_verify_command => "/usr/bin/zypper --non-interactive verify$";

  redhat::
    package_changes => "bulk";
    package_list_command => "/bin/rpm -qa --qf '%{name} %{version}-%{release} %{arch}\n'";
    package_patch_list_command => "/usr/bin/yum ${redhat_knowledge.yum_options} check-update";
    package_list_name_regex    => "^(\S+?)\s\S+?\s\S+$";
    package_list_version_regex => "^\S+?\s(\S+?)\s\S+$";
    package_list_arch_regex    => "^\S+?\s\S+?\s(\S+)$";
    package_installed_regex => ".*";
    package_name_convention => "$(name)";
    package_list_update_command => "/usr/bin/yum ${redhat_knowledge.yum_options} check-update";
    package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";
    package_patch_installed_regex => "^\s.*";
    package_patch_name_regex    => "([^.]+).*";
    package_patch_version_regex => "[^\s]\s+([^\s]+).*";
    package_patch_arch_regex    => "[^.]+\.([^\s]+).*";
    package_add_command    => "/usr/bin/yum ${redhat_knowledge.yum_options} -y install";
    package_update_command => "/usr/bin/yum ${redhat_knowledge.yum_options} -y update";
    package_patch_command => "/usr/bin/yum ${redhat_knowledge.yum_options} -y update";
    package_delete_command => "/bin/rpm -e --nodeps --allmatches";
    package_verify_command => "/bin/rpm -V";
    package_version_less_command => "$(redhat_knowledge.rpm_compare_less)";
    package_version_equal_command => "$(redhat_knowledge.rpm_compare_equal)";

  debian::
    package_changes => "bulk";
    package_list_command => "$(debian_knowledge.call_dpkg) -l";
    package_list_name_regex    => ".i\s+([^\s:]+).*";
    package_list_version_regex => ".i\s+[^\s]+\s+([^\s]+).*";
    package_installed_regex => ".i.*"; # packages that have been uninstalled may be listed
    package_name_convention => "$(name)";
    package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";

    # make correct version comparisons
    package_version_less_command => "$(debian_knowledge.dpkg_compare_less)";
    package_version_equal_command => "$(debian_knowledge.dpkg_compare_equal)";

  debian.have_aptitude::
    package_add_command => "$(debian_knowledge.call_aptitude) $(debian_knowledge.dpkg_options) --assume-yes install";
    package_list_update_command => "/usr/bin/aptitude update";
    package_delete_command => "$(debian_knowledge.call_aptitude) $(debian_knowledge.dpkg_options) --assume-yes remove";
    package_update_command =>  "$(debian_knowledge.call_aptitude) $(debian_knowledge.dpkg_options) --assume-yes install";
    package_patch_command =>  "$(debian_knowledge.call_aptitude) $(debian_knowledge.dpkg_options) --assume-yes install";
    package_verify_command =>  "/usr/bin/aptitude show";
    package_noverify_regex => "(State: not installed|E: Unable to locate package .*)";

    package_patch_list_command => "/usr/bin/aptitude --assume-yes --simulate --verbose full-upgrade";
    package_patch_name_regex => "^Inst\s+(\S+)\s+.*";
    package_patch_version_regex => "^Inst\s+\S+\s+\[?\(?([^\],\s]+).*";

  debian.!have_aptitude::
    package_add_command => "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
    package_list_update_command => "$(debian_knowledge.call_apt_get) update";
    package_delete_command => "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes remove";
    package_update_command =>  "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
    package_patch_command =>  "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
    package_verify_command => "$(debian_knowledge.call_dpkg) -s";
    package_noverify_returncode => "1";

    package_patch_list_command => "$(debian_knowledge.call_apt_get) --just-print dist-upgrade";
    package_patch_name_regex => "^Inst\s+(\S+)\s+.*";
    package_patch_version_regex => "^Inst\s+\S+\s+\[?\(?([^\],\s]+).*";

  freebsd::
    package_changes => "individual";
    package_list_command => "/usr/sbin/pkg_info";
    package_list_name_regex    => "([^\s]+)-.*";
    package_list_version_regex => "[^\s]+-([^\s]+).*";
    package_name_regex    => "([^\s]+)-.*";
    package_version_regex => "[^\s]+-([^\s]+).*";
    package_installed_regex => ".*";
    package_name_convention => "$(name)-$(version)";
    package_add_command => "/usr/sbin/pkg_add -r";
    package_delete_command => "/usr/sbin/pkg_delete";

  alpinelinux::
    package_changes => "bulk";
    package_list_command => "/sbin/apk info -v";
    package_list_name_regex    => "([^\s]+)-.*";
    package_list_version_regex => "[^\s]+-([^\s]+).*";
    package_name_regex    => ".*";
    package_installed_regex => ".*";
    package_name_convention => "$(name)";
    package_add_command => "/sbin/apk add";
    package_delete_command => "/sbin/apk del";

  gentoo::
    package_changes => "individual";
    package_list_command => "/bin/sh -c '/bin/ls -d /var/db/pkg/*/* | cut -c 13-'";
    package_list_name_regex => ".*/([^\s]+)-\d.*";
    package_list_version_regex => ".*/[^\s]+-(\d.*)";
    package_installed_regex => ".*";                          # all reported are installed
    package_name_convention => "$(name)";
    package_list_update_command => "/bin/true";               # I prefer manual syncing
    #package_list_update_command => "/usr/bin/emerge --sync"; # if you like automatic
    package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";
    package_add_command => "/usr/bin/emerge -q --quiet-build";
    package_delete_command => "/usr/bin/emerge --depclean";
    package_update_command => "/usr/bin/emerge --update";
    package_patch_command => "/usr/bin/emerge --update";
    package_verify_command => "/usr/bin/emerge -s";
    package_noverify_regex => ".*(Not Installed|Applications found : 0).*";

  archlinux::
    package_changes => "bulk";
    package_list_command => "/usr/bin/pacman -Q";
    package_list_name_regex    => "(.*)\s+.*";
    package_list_version_regex => ".*\s+(.*)";
    package_installed_regex => ".*";
    package_name_convention => "$(name)";
    package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";
    package_add_command => "/usr/bin/pacman -S --noconfirm --noprogressbar --needed";
    package_delete_command => "/usr/bin/pacman -Rs --noconfirm";
    package_update_command => "/usr/bin/pacman -S --noconfirm --noprogressbar --needed";
}

# Same as ncf_generic with version in package name
# DEPRECATED
body package_method ncf_generic_version
{
  SuSE::
    package_changes => "bulk";
    package_list_command => "/bin/rpm -qa --queryformat \"i | repos | %{name} | %{version}-%{release} | %{arch}\n\"";
    # set it to "0" to avoid caching of list during upgrade
    package_list_update_command => "/usr/bin/zypper --non-interactive refresh";
    package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";
    package_installed_regex => "i.*";
    package_list_name_regex    => "[^|]+\|[^|]+\|\s+([^\s]+).*";
    package_list_version_regex => "[^|]+\|[^|]+\|[^|]+\|\s+([^\s]+).*";
    package_list_arch_regex    => "[^|]+\|[^|]+\|[^|]+\|[^|]+\|\s+([^\s]+).*";
    package_patch_name_regex    => "[^|]+\|\s+([^\s]+).*";
    package_patch_version_regex => "[^|]+\|[^|]+\|\s+([^\s]+).*";
    package_name_convention => "$(name)=$(version)";
    package_add_command => "/usr/bin/zypper --non-interactive install";
    package_delete_command => "/usr/bin/zypper --non-interactive remove --force-resolution";
    package_update_command => "/usr/bin/zypper --non-interactive update";
    package_patch_command => "/usr/bin/zypper --non-interactive patch$"; # $ means no args
    package_verify_command => "/usr/bin/zypper --non-interactive verify$";

  redhat::
    package_changes => "bulk";
    package_list_command => "/bin/rpm -qa --qf '%{name} %{version}-%{release} %{arch}\n'";
    package_patch_list_command => "/usr/bin/yum ${redhat_knowledge.yum_options} check-update";
    package_list_name_regex    => "^(\S+?)\s\S+?\s\S+$";
    package_list_version_regex => "^\S+?\s(\S+?)\s\S+$";
    package_list_arch_regex    => "^\S+?\s\S+?\s(\S+)$";
    package_installed_regex => ".*";
    package_name_convention => "$(name)-$(version)";
    package_list_update_command => "/usr/bin/yum ${redhat_knowledge.yum_options} check-update";
    package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";
    package_patch_installed_regex => "^\s.*";
    package_patch_name_regex    => "([^.]+).*";
    package_patch_version_regex => "[^\s]\s+([^\s]+).*";
    package_patch_arch_regex    => "[^.]+\.([^\s]+).*";
    package_add_command    => "/usr/bin/yum ${redhat_knowledge.yum_options} -y install";
    package_update_command => "/usr/bin/yum ${redhat_knowledge.yum_options} -y update";
    package_patch_command => "/usr/bin/yum ${redhat_knowledge.yum_options} -y update";
    package_delete_command => "/bin/rpm -e --nodeps --allmatches";
    package_verify_command => "/bin/rpm -V";
    package_version_less_command => "$(redhat_knowledge.rpm_compare_less)";
    package_version_equal_command => "$(redhat_knowledge.rpm_compare_equal)";

  debian::
    package_changes => "bulk";
    package_list_command => "$(debian_knowledge.call_dpkg) -l";
    package_list_name_regex    => ".i\s+([^\s:]+).*";
    package_list_version_regex => ".i\s+[^\s]+\s+([^\s]+).*";
    package_installed_regex => ".i.*"; # packages that have been uninstalled may be listed
    package_name_convention => "$(name)=$(version)";
    package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";

    # make correct version comparisons
    package_version_less_command => "$(debian_knowledge.dpkg_compare_less)";
    package_version_equal_command => "$(debian_knowledge.dpkg_compare_equal)";


  debian.have_aptitude::
    package_add_command => "$(debian_knowledge.call_aptitude) $(debian_knowledge.dpkg_options) --assume-yes install";
    package_list_update_command => "/usr/bin/aptitude update";
    package_delete_command => "$(debian_knowledge.call_aptitude) $(debian_knowledge.dpkg_options) --assume-yes remove";
    package_update_command =>  "$(debian_knowledge.call_aptitude) $(debian_knowledge.dpkg_options) --assume-yes install";
    package_patch_command =>  "$(debian_knowledge.call_aptitude) $(debian_knowledge.dpkg_options) --assume-yes install";
    package_verify_command =>  "/usr/bin/aptitude show";
    package_noverify_regex => "(State: not installed|E: Unable to locate package .*)";

    package_patch_list_command => "/usr/bin/aptitude --assume-yes --simulate --verbose full-upgrade";
    package_patch_name_regex => "^Inst\s+(\S+)\s+.*";
    package_patch_version_regex => "^Inst\s+\S+\s+\[?\(?([^\],\s]+).*";

  debian.!have_aptitude::
    package_add_command => "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
    package_list_update_command => "$(debian_knowledge.call_apt_get) update";
    package_delete_command => "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes remove";
    package_update_command =>  "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
    package_patch_command =>  "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
    package_verify_command => "$(debian_knowledge.call_dpkg) -s";
    package_noverify_returncode => "1";

    package_patch_list_command => "$(debian_knowledge.call_apt_get) --just-print dist-upgrade";
    package_patch_name_regex => "^Inst\s+(\S+)\s+.*";
    package_patch_version_regex => "^Inst\s+\S+\s+\[?\(?([^\],\s]+).*";

  freebsd::
    package_changes => "individual";
    package_list_command => "/usr/sbin/pkg_info";
    package_list_name_regex    => "([^\s]+)-.*";
    package_list_version_regex => "[^\s]+-([^\s]+).*";
    package_name_regex    => "([^\s]+)-.*";
    package_version_regex => "[^\s]+-([^\s]+).*";
    package_installed_regex => ".*";
    package_name_convention => "$(name)-$(version)";
    package_add_command => "/usr/sbin/pkg_add -r";
    package_delete_command => "/usr/sbin/pkg_delete";

  alpinelinux::
    package_changes => "bulk";
    package_list_command => "/sbin/apk info -v";
    package_list_name_regex    => "([^\s]+)-.*";
    package_list_version_regex => "[^\s]+-([^\s]+).*";
    package_name_regex    => ".*";
    package_installed_regex => ".*";
    package_name_convention => "$(name)=$(version)";
    package_add_command => "/sbin/apk add";
    package_delete_command => "/sbin/apk del";

  gentoo::
    package_changes => "individual";
    package_list_command => "/bin/sh -c '/bin/ls -d /var/db/pkg/*/* | cut -c 13-'";
    package_list_name_regex => ".*/([^\s]+)-\d.*";
    package_list_version_regex => ".*/[^\s]+-(\d.*)";
    package_installed_regex => ".*";                          # all reported are installed
    package_name_convention => "$(name)";
    package_list_update_command => "/bin/true";               # I prefer manual syncing
    #package_list_update_command => "/usr/bin/emerge --sync"; # if you like automatic
    package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";

    package_add_command => "/usr/bin/emerge -q --quiet-build";
    package_delete_command => "/usr/bin/emerge --depclean";
    package_update_command => "/usr/bin/emerge --update";
    package_patch_command => "/usr/bin/emerge --update";
    package_verify_command => "/usr/bin/emerge -s";
    package_noverify_regex => ".*(Not Installed|Applications found : 0).*";

  archlinux::
    package_changes => "bulk";
    package_list_command => "/usr/bin/pacman -Q";
    package_list_name_regex    => "(.*)\s+.*";
    package_list_version_regex => ".*\s+(.*)";
    package_installed_regex => ".*";
    package_name_convention => "$(name)";
    package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";
    package_add_command => "/usr/bin/pacman -S --noconfirm --noprogressbar --needed";
    package_delete_command => "/usr/bin/pacman -Rs --noconfirm";
    package_update_command => "/usr/bin/pacman -S --noconfirm --noprogressbar --needed";
}

# Same as apt_get from CFEngine lib with version in package name
# DEPRECATED
body package_method apt_get_version
{
    package_changes => "bulk";
    package_list_command => "$(debian_knowledge.call_dpkg) -l";
    package_list_name_regex => "$(debian_knowledge.list_name_regex)";
    package_list_version_regex => "$(debian_knowledge.list_version_regex)";
    package_installed_regex => ".i.*"; # packages that have been uninstalled may be listed
    package_name_convention => "$(name)=$(version)";

    # set it to "0" to avoid caching of list during upgrade
    package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";

    # Target a specific release, such as backports
    package_add_command => "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
    package_list_update_command => "$(debian_knowledge.call_apt_get) update";
    package_delete_command => "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes -q remove";
    package_update_command =>  "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
    package_patch_command =>  "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
    package_verify_command => "$(debian_knowledge.call_dpkg) -s";
    package_noverify_returncode => "1";

    package_patch_list_command => "$(debian_knowledge.call_apt_get) --just-print dist-upgrade";
    package_patch_name_regex => "$(debian_knowledge.patch_name_regex)";
    package_patch_version_regex => "$(debian_knowledge.patch_version_regex)";

    # make correct version comparisons
    package_version_less_command => "$(debian_knowledge.dpkg_compare_less)";
    package_version_equal_command => "$(debian_knowledge.dpkg_compare_equal)";
}

########################################################################
# Install a package using rug                                          #
########################################################################
# DEPRECATED
body package_method rudder_rug
{
    package_changes               => "individual";

    package_list_command          => "/bin/rpm -qa --queryformat \"i | repos | %{name} | %{version}-%{release} | %{arch}\n\"";
    package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";
    package_installed_regex       => "i.*";
    package_list_name_regex       => "[^|]+\|[^|]+\|\s+([^\s]+).*";
    package_list_version_regex    => "[^|]+\|[^|]+\|[^|]+\|\s+([^\s]+).*";
    package_list_arch_regex       => "[^|]+\|[^|]+\|[^|]+\|[^|]+\|\s+([^\s]+).*";

    package_name_convention       => "${name}";
    package_add_command           => "/usr/bin/rug install -y";
    package_delete_command        => "/usr/bin/rug remove -y";
    package_update_command        => "/usr/bin/rug update -y";

    package_verify_command        => "/usr/bin/rug verify -y$"; # $ means no args

    # make correct version comparisons
    package_version_less_command  => "${rudder_rpm_knowledge.rpm_compare_less}";
    package_version_equal_command => "${rudder_rpm_knowledge.rpm_compare_equal}";
}

########################################################################
# Install a package using yum but with a check from rpm                #
########################################################################
# DEPRECATED
body package_method rudder_yum
{
    package_changes               => "bulk";
    package_list_command          => "/bin/rpm -qa --qf '%{name} %{version}-%{release} %{arch}\n'";
    package_list_name_regex       => "^(\S+?)\s\S+?\s\S+$";
    package_list_version_regex    => "^\S+?\s(\S+?)\s\S+$";
    package_list_arch_regex       => "^\S+?\s\S+?\s(\S+)$";
    package_installed_regex       => ".*";
    package_name_convention       => "${name}";
    package_list_update_command   => "/usr/bin/yum ${redhat_knowledge.yum_options} check-update";
    package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";
    package_patch_name_regex      => "([^.]+).*";
    package_patch_version_regex   => "[^\s]\s+([^\s]+).*";
    package_patch_arch_regex      => "[^.]+\.([^\s]+).*";
    package_add_command           => "/usr/bin/yum ${redhat_knowledge.yum_options} -y install";
    package_update_command        => "/usr/bin/yum ${redhat_knowledge.yum_options} -y update";
    package_patch_command         => "/usr/bin/yum ${redhat_knowledge.yum_options} -y update";
    package_delete_command        => "/bin/rpm -e --nodeps --allmatches";
    package_verify_command        => "/bin/rpm -V";

    # make correct version comparisons
    package_version_less_command  => "${rudder_rpm_knowledge.rpm_compare_less}";
    package_version_equal_command => "${rudder_rpm_knowledge.rpm_compare_equal}";
}

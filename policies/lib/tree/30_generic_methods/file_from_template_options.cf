#####################################################################################
# Copyright 2025 Normation SAS
#####################################################################################
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, Version 3.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#####################################################################################

# @name File from template
# @description Build a file from a template (MiniJinja, Jinja2, Mustache)
# @documentation The `file_from_template` method renders a template into a destination file using one of the supported template engines.
#
# ### Template Rendering:
#   Renders a template using the specified `engine` (`minijinja`, `mustache`, or `jinja2`) into the file given in `destination`.
#
# ### Data Sources:
#   - If `data` is provided, the template will only use those data to render the template. The agent datastate will not be passed to the templating engine.
#   - If `data` is not provided, the **agent datastate** is used instead (containing the existing variables and classes of the current agent run).
#
# ### Template Source:
#   - `template_string`: Inline template string.
#   - `template_path`: Path to an external template file.
#   - These two options are **mutually exclusive** — exactly one must be used.
#
# ### Show Content:
#   - If `show_content: true`, the rendered file’s content will be dumped to the report.
#
#  ### Engines:
#   - `minijinja`
#     - Aborts rendering if undefined variables are used. Custom filters can not be added but the agent comes with a great variety of builtin usable filters.
#   - `mustache`
#     - Ignores undefined variables gracefully.
#   - `jinja2`
#     - Aborts rendering if undefined variables are used.
#     - Requires `python3-jinja2` to be installed.
#     - Not supported on Windows agents
#
# Complete documentation for the different supported engines can be found [here](https://docs.rudder.io/techniques/9.0/modules/template.html#minijinja).
#
# ### Examples
#
# ####  Inline template string
# ```yaml
# name: render_simple
# method: file_from_template_options
# params:
#   destination: /tmp/render.txt
#   engine: minijinja
#   template_string: "{{foo}}"
#   data: "{\"foo\": \"bar\"}"
#   show_content: true
# ```
#
# This renders the string `bar` into `/tmp/render.txt` and also outputs the content.
#
# ---
#
# #### Template file with Mustache
# ```yaml
# name: render_from_file
# method: file_from_template_options
# params:
#   destination: /tmp/result.txt
#   engine: mustache
#   template_path: ${resources_dir}/template.mustache
#   data: "{\"user\": \"Alice\", \"role\": \"admin\"}"
#   show_content: false
# ```
#
# This renders the `template.mustache` template with provided JSON data and writes it to `/tmp/result.txt`.
#
# ---
#
# #### Jinja2 with missing variables (will fail)
# ```yaml
# name: render_fail
# method: file_from_template_options
# params:
#   destination: /tmp/fail.txt
#   engine: jinja2
#   template_string: "{{unknown}}"
#   show_content: true
# ```
#
# This will return an **error** since `unknown` is not defined in `data` or the agent context.
#
# @parameter            destination Destination file (absolute path on the target node)
# @parameter_constraint destination "allow_empty_string" : false
# @parameter            engine Template engine: "minijinja", "jinja2" or "mustache" (defaults to "minijinja")
# @parameter_constraint engine "allow_empty_string" : true
# @parameter_constraint engine "select" : [ "", "minijinja", "jinja2", "mustache" ]
# @parameter            data Data provided to the template as JSON, defaults to the global context if empty
# @parameter_constraint data "allow_empty_string" : true
# @parameter_constraint data "valid_format" : "json"
# @parameter            template_string String containing the template to be rendered
# @parameter_constraint template_string "allow_empty_string" : true
# @parameter            template_path  Source file containing a template to be rendered (absolute path on the target node)
# @parameter_constraint template_path "allow_empty_string" : true
# @parameter            show_content Show the file content in the report, "true" or "false" (defaults to "true")
# @parameter_constraint show_content "allow_empty_string" : true
# @parameter_constraint show_content "select" : [ "", "true", "false" ]
#
# @class_prefix file_from_template_options
# @class_parameter destination
# @agent_support = ["cfengine-community", "dsc"]

promise agent template {
  path => "/opt/rudder/bin/rudder-module-template";
}

bundle agent file_from_template_options(destination, engine, data, template_string, template_path, show_content) {
  vars:
      "module_file"  string => "/opt/rudder/bin/rudder-module-template";
      "class_prefix" string => canonify("file_from_template_options_${destination}");

  defaults:
      "engine"       string => "minijinja", if_match_regex => "";
      "show_content" string => "true", if_match_regex => "";

  classes:
      "has_module"   expression => fileexists("${module_file}");
      "pass3" expression => "pass2";
      "pass2" expression => "pass1";
      "pass1" expression => "any";

  methods:
    pass3.has_module::
      "${report_data.method_id}" usebundle => call_method("rudder_actual_file_from_template_options");
      "${report_data.method_id}" usebundle => rudder_actual_file_from_template_options("${destination}", "${engine}", "${data}", "${template_string}", "${template_path}", "${show_content}");
      "${report_data.method_id}" usebundle => call_method_classes("${class_prefix}");
      "${report_data.method_id}" usebundle => call_method_classes_caller;
      "${report_data.method_id}" usebundle => call_method_end("rudder_actual_file_from_template_options");
      "${report_data.method_id}" usebundle => log_rudder_v4("${destination}", "${rudder_actual_file_from_template_options.report}", "");

    pass3.!has_module::
      "${report_data.method_id}" usebundle => _classes_failure("${class_prefix}");
      "${report_data.method_id}" usebundle => _classes_failure("${report_data.method_id}");
      "${report_data.method_id}" usebundle => log_rudder_v4("${destination}", "Template module is not supported on this agent", "");
}

bundle agent template_module_serializer(r_destination, r_engine, r_data, r_template_string, r_template_path, r_datastate_path, r_report_file) {
  vars:
    "path"            string => "${r_destination}";
    "engine"          string => "${r_engine}";
    "data"            string => "${r_data}";
    "template_string" string => "${r_template_string}";
    "template_path"   string => "${r_template_path}";
    "datastate_path"  string => "${r_datastate_path}";
    "report_file"     string => "${r_report_file}";
}

bundle agent rudder_actual_file_from_template_options(destination, engine, data, template_string, template_path, show_content) {
  vars:
   "destination_c" string => canonify("${destination}");
   "report_file" string => "/var/rudder/tmp/rudder-module-template${destination_c}.log";
   pass1.data_is_empty::
     "datastate_path"  string => "/var/rudder/tmp/datastate-${this.promiser_pid}.json";
   pass1.!data_is_empty::
     "datastate_path"  string => "";
   pass1::
     "string_params"     data => bundlestate("template_module_serializer");
     "bool_params"       data => '---
show_content: ${show_content}
';
     "inputs_as_data"    data => mergedata('string_params', 'bool_params');
     "module_inputs"   string => storejson('inputs_as_data');
   pass2::
     "report"      string => readfile("${report_file}", "0"),
                        if => "has_report";

  classes:
    pass2::
      "has_report"   expression => fileexists("${report_file}");

    any::
      "pass3"         expression => "pass2";
      "pass2"         expression => "pass1";
      "pass1"         expression => "any";
      "data_is_empty" expression => strcmp("${data}", "");

  files:
    pass1.!pass2.data_is_empty::
      "${datastate_path}"
        template_method      => "inline_mustache",
        create               => "true",
        edit_defaults        => no_backup,
        edit_template_string => "{{%-top-}}";

    pass3.has_report::
      "${report_file}"
        delete => tidy,
        action => immediate_ignore_dry_run;

  methods:
     pass1.!pass2::
       "serialize"               usebundle => template_module_serializer("${destination}",
                                                                         "${engine}",
                                                                         "${data}",
                                                                         "${template_string}",
                                                                         "${template_path}",
                                                                         "${datastate_path}",
									 "${report_file}");
     pass3.data_is_empty::
      # In non audit mode, we need to force enforce mode to remove the temp files.
      "${report_data.method_id}" usebundle => push_dry_run_mode("false");
      "${report_data.method_id}" usebundle => call_method("file_absent");
      "${report_data.method_id}" usebundle => file_absent("${datastate_path}");
      "${report_data.method_id}" usebundle => call_method_end("file_absent");
      "${report_data.method_id}" usebundle => pop_dry_run_mode();

     pass3.!has_report::
        "error" usebundle => _classes_failure("${report_data.method_id}");

  template:
    pass2.!pass3.!(global_dry_run|dry_run)::
      "module_call"
        rudder_module_protocol  => "0",
        state_dir               => "/var/rudder/tmp/",
        backup_dir              => "/var/rudder/modified-files/",
        node_id                 => "${g.uuid}",
        agent_frequency_minutes => "${g.agent_run_interval}",
        classes                 => classes_generic("${report_data.method_id}"),
        data                    => "${module_inputs}";

    pass2.!pass3.(global_dry_run|dry_run)::
      "module_call"
        action_policy           => "warn",
        rudder_module_protocol  => "0",
        state_dir               => "/var/rudder/tmp/",
        backup_dir              => "/var/rudder/modified-files/",
        node_id                 => "${g.uuid}",
        agent_frequency_minutes => "${g.agent_run_interval}",
        classes                 => classes_generic("${report_data.method_id}"),
        data                    => "${module_inputs}";
}

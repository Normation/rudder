#####################################################################################
# Copyright 2025 Normation SAS
#####################################################################################
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, Version 3.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#####################################################################################

# @name Command execution options
# @description command execution
# @documentation Coming soon.
#
# @parameter            command Command to be executed
# @parameter_constraint command "allow_empty_string" : false
# @parameter            args Arguments to the command
# @parameter_constraint args "allow_empty_string" : true
# @parameter            run_in_audit_mode Specify if command must be run in audit mode
# @parameter_constraint run_in_audit_mode "allow_empty_string" : true
# @parameter_constraint run_in_audit_mode "select" : [ "", "true", "false" ]
# @parameter            in_shell Specify whether the command should be executed within a shell
# @parameter_constraint in_shell "allow_empty_string" : true
# @parameter_constraint in_shell "select" : [ "", "true", "false" ]
# @parameter            shell_path Define the path to the shell to be used (applicable only in shell mode)
# @parameter_constraint shell_path "allow_empty_string" : true
# @parameter            chdir Set the working directory from which the command will be executed
# @parameter_constraint chdir "allow_empty_string" : true
# @parameter            timeout Define a timeout duration for the command execution
# @parameter_constraint timeout "allow_empty_string" : true
# @parameter            stdin Provide input to the standard input (stdin) of the executed command
# @parameter_constraint stdin "allow_empty_string" : true
# @parameter            stdin_add_newline Control whether a newline character is appended to the stdin input
# @parameter_constraint stdin_add_newline "allow_empty_string" : true
# @parameter_constraint stdin_add_newline "select" : [ "", "true", "false" ]
# @parameter            compliant_codes Specify the compliant codes
# @parameter_constraint compliant_codes "allow_empty_string" : true
# @parameter            repaired_codes Specify the repaired codes
# @parameter_constraint repaired_codes "allow_empty_string" : true
# @parameter            output_to_file Define a file path to store the output generated by the command
# @parameter_constraint output_to_file "allow_empty_string" : true
# @parameter            strip_output Controls if the EOL is strip from the output
# @parameter_constraint strip_output "allow_empty_string" : true
# @parameter_constraint strip_output "select" : [ "", "true", "false" ]
# @parameter            uid Specify the user ID (UID) under which the command will be executed
# @parameter_constraint uid "allow_empty_string" : true
# @parameter            gid Specify the group ID (GID) under which the command will be executed
# @parameter_constraint gid "allow_empty_string" : true
# @parameter            umask Set the umask value for the executed command
# @parameter_constraint umask "allow_empty_string" : true
# @parameter            env_vars The variables to pass to the environment of the executed command
# @parameter_constraint env_vars "allow_empty_string" : true
# @parameter            show_content Controls output of the report
# @parameter_constraint show_content "allow_empty_string" : true
# @parameter_constraint show_content "select" : [ "", "true", "false" ]
#
# @class_prefix command_execution_options
# @class_parameter command
# @agent_support = ["cfengine-community"]

promise agent ruddercommands {
  path => "/opt/rudder/bin/rudder-module-commands";
}

bundle agent command_execution_options(command, args, run_in_audit_mode, in_shell, shell_path, chdir, timeout, stdin, stdin_add_newline, compliant_codes, repaired_codes, output_to_file, strip_output, uid, gid, umask, env_vars, show_content) {
  vars:
      "module_file"  string => "/opt/rudder/bin/rudder-module-commands";
      "class_prefix" string => canonify("command_execution_options_${command}");

  defaults:
      "run_in_audit_mode" string => "false",   if_match_regex => "";
      "in_shell"          string => "false",   if_match_regex => "";
      "shell_path"        string => "/bin/sh", if_match_regex => "";
      "stdin_add_newline" string => "true",    if_match_regex => "";
      "strip_output"      string => "false",   if_match_regex => "";
      "show_content"      string => "true",    if_match_regex => "";
      "uid"               string => "0",       if_match_regex => "";
      "gid"               string => "0",       if_match_regex => "";
      "umask"             string => "0022",    if_match_regex => "";
      "timeout"           string => "30",      if_match_regex => "";
      "repaired_codes"    string => "0",       if_match_regex => "";

  classes:
      "has_module"   expression => fileexists("${module_file}");

      "pass3" expression => "pass2";
      "pass2" expression => "pass1";
      "pass1" expression => "any";

  methods:
    pass3.has_module::
      "${report_data.method_id}" usebundle => call_method("rudder_actual_command_execution_options");
      "${report_data.method_id}" usebundle => rudder_actual_command_execution_options("${command}", "${args}", "${run_in_audit_mode}", "${in_shell}", "${shell_path}", "${chdir}", "${timeout}", "${stdin}", "${stdin_add_newline}", "${compliant_codes}", "${repaired_codes}", "${output_to_file}", "${strip_output}", "${uid}", "${gid}", "${umask}", "${env_vars}", "${show_content}");
      "${report_data.method_id}" usebundle => call_method_classes("${class_prefix}");
      "${report_data.method_id}" usebundle => call_method_classes_caller;
      "${report_data.method_id}" usebundle => call_method_end("rudder_actual_command_execution_options");
      "${report_data.method_id}" usebundle => log_rudder_v4("${command}", "Execution of ${command}", "");

    pass3.!has_module::
      "${report_data.method_id}" usebundle => _classes_failure("${class_prefix}");
      "${report_data.method_id}" usebundle => _classes_failure("${report_data.method_id}");
      "${report_data.method_id}" usebundle => log_rudder_v4("${command}", "Commands module is not supported on this agent", "");
}

bundle agent command_module_serializer(r_command, r_args, r_shell_path, r_chdir, r_timeout, r_stdin, r_compliant_codes, r_repaired_codes, r_output_to_file, r_uid, r_gid, r_umask, r_env_vars) {
  vars:
    "command"         string => "${r_command}";
    "args"            string => "${r_args}";
    "shell_path"      string => "${r_shell_path}";
    "chdir"           string => "${r_chdir}";
    "timeout"         string => "${r_timeout}";
    "stdin"           string => "${r_stdin}";
    "compliant_codes" string => "${r_compliant_codes}";
    "repaired_codes"  string => "${r_repaired_codes}";
    "output_to_file"  string => "${r_output_to_file}";
    "uid"             string => "${r_uid}";
    "gid"             string => "${r_gid}";
    "umask"           string => "${r_umask}";
    "env_vars"        string => "${r_env_vars}";
}

bundle agent rudder_actual_command_execution_options(command, args, run_in_audit_mode, in_shell, shell_path, chdir, timeout, stdin, stdin_add_newline, compliant_codes, repaired_codes, output_to_file, strip_output, uid, gid, umask, env_vars, show_content) {
  vars:
    # The best serializer provided by cfengine is the 'bundlestate' function. As I could not find how to merge partial data containers,
    # we need to define a "serializer" bundle used to serialize every string type args expected by the module.
    pass2::
      "string_data"            data => bundlestate("command_module_serializer");
      "bool_data"              data => '---
run_in_audit_mode: ${run_in_audit_mode}
in_shell: ${in_shell}
stdin_add_newline: ${stdin_add_newline}
strip_output: ${strip_output}
show_content: ${show_content}
';
      "data"            data => mergedata('string_data', 'bool_data');
      "module_inputs" string => storejson("data");

  classes:
      "pass3" expression => "pass2";
      "pass2" expression => "pass1";
      "pass1" expression => "any";

  methods:
    pass2.!pass3::
      "serialize" usebundle => command_module_serializer("${command}",
                                                         "${args}",
                                                         "${shell_path}",
                                                         "${chdir}",
                                                         "${timeout}",
                                                         "${stdin}",
                                                         "${compliant_codes}",
                                                         "${repaired_codes}",
                                                         "${output_to_file}",
                                                         "${uid}",
                                                         "${gid}",
                                                         "${umask}",
                                                         "${env_vars}");
  ruddercommands:
    pass3::
      "module_call"
        rudder_module_protocol  => "0",
        state_dir               => "/var/rudder/tmp/",
        backup_dir              => "/var/rudder/modified-files/",
        node_id                 => "${g.uuid}",
        agent_frequency_minutes => "${g.agent_run_interval}",
        classes                 => classes_generic("${report_data.method_id}"),
        data                    => "${module_inputs}";
}

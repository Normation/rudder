use crate::{Commands, CommandsParameters, get_used_cmd};
use anyhow::{Context, Result};
use clap::Parser;

use itertools::Itertools;
use std::{env, path::PathBuf};

#[derive(Parser)]
#[command(version, about, long_about = None)]
pub struct Cli {
    /// Command to be executed
    command: String,

    /// Enable audit mode
    #[arg(short, long)]
    audit: bool,

    /// Arguments to the command
    args: Option<Vec<String>>,

    /// Simulate the command execution without making any changes
    #[arg(short, long)]
    dry_run: bool,

    /// Specify whether the command should be executed within a shell
    #[arg(long, group = "shell")]
    in_shell: bool,

    /// Define the path to the shell to be used (applicable only in shell mode)
    #[arg(long, requires = "shell")]
    shell_path: Option<String>,

    /// Set the working directory from which the command will be executed
    #[arg(long)]
    chdir: Option<String>,

    /// Define a timeout duration for the command execution
    #[arg(long)]
    timeout: Option<String>, // Default to 30 seconds

    /// Provide input to the standard input (stdin) of the executed command
    #[arg(long)]
    stdin: Option<String>,

    /// Control whether a newline character is appended to the stdin input
    #[arg(long)]
    stdin_no_newline: bool,

    /// Define a file path to store the output generated by the command
    #[arg(long)]
    output_to_file: Option<PathBuf>,

    /// Controls if the EOL is strip from the output
    #[arg(long)]
    strip_output: bool, // Default to false

    /// Specify the user ID (UID) under which the command will be executed
    #[arg(long)]
    uid: Option<String>,

    /// Specify the group ID (GID) under which the command will be executed
    #[arg(long)]
    gid: Option<String>,

    /// Set the umask value for the executed command
    #[arg(long)]
    umask: Option<String>,

    /// Control whether to share the environment variables with the executed command
    #[arg(long)]
    share_env: bool, // Default to false
}

impl Cli {
    pub fn run() -> Result<()> {
        let cli = Cli::parse();
        let audit = cli.audit;

        let p = Cli::get_parameters(cli);
        let cmd = get_used_cmd(&p);

        if audit && !p.run_in_audit_mode {
            println!("dry-run: {cmd}");
        } else {
            let output = Commands::run(&p, audit)
                .with_context(|| format!("Failed to run command '{cmd}'"))?;
            let output = serde_json::to_string_pretty(&output)?;

            println!("Command '{cmd}':\n{output}");
        }

        Ok(())
    }

    fn get_parameters(cli: Cli) -> CommandsParameters {
        let args = if let Some(args) = &cli.args {
            Some(args.join(" "))
        } else {
            None
        };
        let env = if cli.share_env {
            let serialized_env = env::vars().map(|(k, v)| format!("{k}={v}")).join("\n");

            Some(serialized_env)
        } else {
            None
        };
        CommandsParameters {
            command: cli.command,
            args,
            run_in_audit_mode: !cli.dry_run,
            in_shell: cli.in_shell,
            shell_path: cli.shell_path.unwrap_or_else(Commands::default_shell_path),
            chdir: cli.chdir,
            timeout: cli.timeout.unwrap_or_else(Commands::default_timeout),
            stdin: cli.stdin,
            stdin_add_newline: !cli.stdin_no_newline,
            compliant_codes: None,
            repaired_codes: Commands::default_repaired_codes(),
            output_to_file: cli.output_to_file,
            strip_output: cli.strip_output,
            uid: cli.uid,
            gid: cli.gid,
            umask: cli.umask,
            env_vars: env,
            show_content: true,
        }
    }
}

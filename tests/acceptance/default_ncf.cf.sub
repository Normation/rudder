# Create the list of all the base file to load to test
# It requires the NCF_TREE environment variable to be defined
bundle common ncf_inputs
{
  vars:
      "ncf_tree" string => getenv("NCF_TREE", 1024);

      # Almost same as promises.cf, but only load necessary parts
      "list_compatible_inputs" string => "/bin/sh ${ncf_tree}/10_ncf_internals/list-compatible-inputs";
      "capability_file"        string => "/opt/rudder/etc/agent-capabilities";

      "generic_framework"      string => execresult("${list_compatible_inputs} --capability-file ${capability_file} --agent-version ${sys.cf_version} --ncf-path ${ncf_tree} 10_ncf_internals 20_cfe_basics 30_generic_methods 40_it_ops_knowledge", "useshell");

      "default_files_relative" slist => splitstring("${generic_framework}", "\n", 10000);
      "default_files"         slist => maplist("${ncf_tree}/${this}", default_files_relative);

}

# Load a custom ncf.conf for tests
bundle common ncf_configuration {
  vars:
      "ncf_configuration_basedir" string => dirname("${this.promise_filename}");
      "ncf_configuration_file" string => "${ncf_configuration_basedir}/ncf.conf";
}

bundle common test_utils {

  vars:
    have_perl::
      "file_perms" string => "${paths.perl} -e 'printf \"%03o\\n\", (stat)[2] & 07777, $_ for @ARGV'";
      "file_owner" string => "${paths.perl} -e 'printf \"%d\\n\", (stat)[4], $_ for @ARGV'";
      "file_group" string => "${paths.perl} -e 'printf \"%d\\n\", (stat)[5], $_ for @ARGV'";
    test_utils_pass2.!have_perl::
      "file_perms" string => "/usr/bin/stat -c %a ${file}";
      "file_owner" string => "/usr/bin/stat -c %u ${file}";
      "file_group" string => "/usr/bin/stat -c %g ${file}";

  classes:
      "have_perl" expression => fileexists("${paths.perl}");
      "test_utils_pass2"     expression => "any";
}

bundle agent define_expected_classes(class_prefix, status, id)
{
  vars:
      "complete_suffix" slist => {"not_kept", "kept", "not_ok", "ok", "not_repaired", "repaired", "failed", "error"};
      "error_suffix"    slist => {"not_kept", "not_ok", "not_repaired", "failed", "error"};
      "repaired_suffix" slist => { "ok", "repaired", "not_kept" };
      "success_suffix"  slist => { "ok", "kept", "not_repaired" };

      "expected_string_${id}"   string => concat(join(".", maplist("${class_prefix}_${this}", "@{${status}_suffix}")), ".${class_prefix}_reached");
      "unexpected_string_${id}" string => join("|", maplist("${class_prefix}_${this}", difference(complete_suffix, "${status}_suffix")));

      "report_string_${id}"      string => "(${expected_string_${id}}).!(${unexpected_string_${id}})";
      "expected_classes_${id}"   slist => maplist("${class_prefix}_${this}", "@{${status}_suffix}");
      "unexpected_classes_${id}" slist => maplist("${class_prefix}_${this}", difference(complete_suffix, "@{${status}_suffix}"));
}

bundle agent execute_serverspec(test_name, class_name, comment)
{
  vars:
      "fanion"        string => "\n#####################################\n";
    pass2::
      "result" string => "SUCCESS",
          ifvarclass => "${class_name}";
      "result" string => "FAILURE",
          ifvarclass => "!${class_name}";
      "report_string" string => "${fanion}Executing: ruby -S rspec ${ncf_configuration.ncf_configuration_basedir}/spec/localhost/${test_name} --format documentation #${comment}\n==>${result}${fanion}";

  classes:
      "pass3" expression => "pass2";
      "pass2" expression => "pass1";
      "pass1" expression => "any";

    pass1::
      "${class_name}" expression => returnszero("ruby -S rspec ${ncf_configuration.ncf_configuration_basedir}/spec/localhost/${test_name} --format documentation #${comment}", "useshell"),
          scope => "namespace";

  reports:
    pass3::
      "${report_string}";

}

# This bundle should be call when testing a generic method.
# It will call the target bundle with the given arguments,
# check that the resulting classes are correct and define
# a global class "${result_class}_ok" if everything succeed.
#
# name: name of the target bundle
# args: slist containing the target bundle parameter, in 
#       correct order.
# status: expected result status, can be: success, error, repaired
# result_class: prefix of the resulting class
bundle agent apply_gm(name, args, status, result_class, mode)
{
  vars:
      "length"  int => length("args");
      "arg0" string => nth("args", "0");
      "arg1" string => nth("args", "1");
      "arg2" string => nth("args", "2");
      "arg3" string => nth("args", "3");
      "arg4" string => nth("args", "4");
      "arg5" string => nth("args", "5");

      "old_class_prefix" string => "${${name}.old_class_prefix}";

      "report_param" string => join("_", args);
      "full_class_prefix" string => canonify("${name}_${report_param}");
      "class_prefix" string => string_head("${full_class_prefix}", "1000");

  classes:
      "pass3" expression => "pass2";
      "pass2" expression => "pass1";
      "pass1" expression => "any";

      "audit" expression => strcmp("${mode}", "audit");

      # Dynamic bundle call does not support undefined arg number
      # We have to explicitly define each possibility
      "1_arg" expression => strcmp("${length}", "1");
      "2_arg" expression => strcmp("${length}", "2");
      "3_arg" expression => strcmp("${length}", "3");
      "4_arg" expression => strcmp("${length}", "4");
      "5_arg" expression => strcmp("${length}", "5");
      "6_arg" expression => strcmp("${length}", "6");
      "7_arg" expression => strcmp("${length}", "7");
      "8_arg" expression => strcmp("${length}", "8");

    pass2::
      "old_class_prefix_ok" expression => "${define_expected_classes.report_string_old_class_prefix_${result_class}}";
      "class_prefix_ok"     expression => "${define_expected_classes.report_string_class_prefix_${result_class}}";
      "${result_class}_ok"  expression => "old_class_prefix_ok.class_prefix_ok",
        scope => "namespace";


  methods:
      "expected_classes" usebundle => define_expected_classes("${class_prefix}", "${status}", "class_prefix_${result_class}");
      "expected_classes" usebundle => define_expected_classes("${old_class_prefix}", "${status}", "old_class_prefix_${result_class}");

    audit::
      "enable_${class_prefix}" usebundle => set_dry_run_mode("true");

    1_arg::
      "execute_gm" usebundle => ${name}("${arg0}");
    2_arg::
      "execute_gm" usebundle => ${name}("${arg0}", "${arg1}");
    3_arg::
      "execute_gm" usebundle => ${name}("${arg0}", "${arg1}", "${arg2}");
    4_arg::
      "execute_gm" usebundle => ${name}("${arg0}", "${arg1}", "${arg2}", "${arg3}");
    5_arg::
      "execute_gm" usebundle => ${name}("${arg0}", "${arg1}", "${arg2}", "${arg3}", "${arg4}");
    6_arg::
      "execute_gm" usebundle => ${name}("${arg0}", "${arg1}", "${arg2}", "${arg3}", "${arg4}", "${arg5}");
    7_arg::
      "execute_gm" usebundle => ${name}("${arg0}", "${arg1}", "${arg2}", "${arg3}", "${arg4}", "${arg5}", "${arg6}");
    8_arg::
      "execute_gm" usebundle => ${name}("${arg0}", "${arg1}", "${arg2}", "${arg3}", "${arg4}", "${arg5}", "${arg6}", "${arg7}");

    pass3.audit::
      "disable_${class_prefix}" usebundle => set_dry_run_mode("false");

    pass3::
      "cancel_classes" usebundle => _classes_cancel("${class_prefix}");
      "cancel_classes" usebundle => _classes_cancel("${old_class_prefix}");

  reports:
    pass2.!pass3::
      "Missing expected old class ${define_expected_classes.expected_classes_old_class_prefix_${result_class}}"
        ifvarclass => "!${define_expected_classes.expected_classes_old_class_prefix_${result_class}}";

      "Missing expected class ${define_expected_classes.expected_classes_class_prefix_${result_class}}"
        ifvarclass => "!${define_expected_classes.expected_classes_class_prefix_${result_class}}";

      "Found unexpected old class ${define_expected_classes.unexpected_classes_old_class_prefix_${result_class}}"
        ifvarclass => "${define_expected_classes.unexpected_classes_old_class_prefix_${result_class}}";

      "Found unexpected class ${define_expected_classes.unexpected_classes_class_prefix_${result_class}}"
        ifvarclass => "${define_expected_classes.unexpected_classes_class_prefix_${result_class}}";
}
